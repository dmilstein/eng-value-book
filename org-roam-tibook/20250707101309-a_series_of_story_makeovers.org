:PROPERTIES:
:ID:       EFA43963-DB19-4EA6-8EF3-4F4376AED1F1
:END:
#+title: A Series of Story Makeovers
#+filetags: :Chapter:
* A Series of Story Makeovers
** "Cutting a Ball of Spaghetti In Half"
*** What The Engineer Said At Friday Wins
# The One-Sentence Win That No One Will Feel In Their Bones

"Team Ultimate Werewolves finished implementing the field catalog interface."

*** What Their Team Actually Did

Their team own the data model for the core application. They built an API that allows other teams to list all available fields, and, for each, obtain methods to read and update data.

*** A Three Beat Story

We've badly struggled with having teams work in parallel on our core product -- but we *need* to be able to have multiple teams working in there if we're going to have any chance of hitting our launch target for next year. That kind of parallel development has been basically impossible up to now.

My team, the Ultimate Werewolves, spent the last two months carefully reworking some of our hoariest old code, to put in place an API for a "catalog of available data". That API lists all available fields, along with, for each, new endpoints we're adding to both read and update the data.

As of last Thursday, at four pm, Team Dromedary can now build their awesome new report builder tool *purely on top of that catalog API*. They can do *all* of their work without directly touching any of the core code -- and thus, without talking to or waiting on my team for almost anything. And *my* team can now do a ton of work under the hood, totally independently of the Droms, to add new fields, fix the search indexing, and deal with some performance challenges.

Both teams have *already* found planning going faster and we believe we're going to speed up even more over the next few months.

*** Story Technique Notes

 - The first paragraph steadily makes the problem worse and worse

   /We've badly struggled/... /but we *need* to/... /to have any chance of hitting/... /basically impossible/

   It's always good to see if you can find ways to make the problem more and more severe -- even subtly, within a single sentence.

 - The second paragraph casts the work as a "meaningful struggle"

   /*spent* two months/... /*carefully* reworking/... /*hoariest* old code/.

 - The third paragraph brings the listener into a key moment

   /*As of last Thursday at 4 pm*, Team Dromedary can now build.../

 - The conclusion invokes a better world

   /We believe we're going to speed up *even more*/

*** The Value Being Illustrated

Enabling parallel development across multiple teams can be *incredibly* valuable to a business -- and can only enabled by smart, often deeply technical investments.

This kind of work is an absolute poster child for forms of value which are, by default, *almost entirely opaque to stakeholders*.

Thus, being able to *tell the story* of that creation of value, as above, can serve you very well.

In fact, the wise engineering leader will, a few months later, as new features are rolling out, return to this story and remind everyone that the pace of discovery and development was only made possible by this investment.

All that said, please, please, *please* don't do this kind of work *speculatively*.

Wait until you run into actual problems trying to do actual work across multiple actual teams.

If some engineer decides to insert a "clearly useful" abstraction layer for no reason other than because it "feels cleaner", that engineer will, essentially 100% of the time, predict the *wrong kind* of parallel decomposition your business will later need.

You'll run a very grave risk of making all work harder, and making the actual parallel decomposition you need *fully impossible*.

A reasonable shorthand summary is: don't build microservices until you have a successful and somewhat *extremely* frustrating monolith.

** "Unspringing the React Testing Bear Trap"
*** What The Engineer Said At Friday Wins
"We finished restructuring the front-end tests for the builder".

*** What Their Team Actually Did
The lead front-end engineer on the team implemented a new pattern for React components. Among other things, that pattern makes it much easier to test the front-end code.

*** A Three Beat Story

Our front-end tests for the builder were all written by engineers who were learning React *and* how to write unit tests... at the same time. Unfortunately, the resulting tests randomly fail a lot and *also* have to be rewritten every time we so much as breathe on the underlying code. The PM's started to get really frustrated that every ticket had an extra two days to "fix tests". One day in planning, our PM, Amber, suggested we should maybe just stop testing altogether. But that felt really risky, so the engineers all pushed back. But it didn't feel great.

So, we peeled Jeremiah away from day-to-day sprint work, and he spent a while going deep to try to understand why the failures were happening, and what we could do to make the tests more stable across code changes. He realized the underlying problem wasn't actually the tests themselves, but more how we were managing state in the builder. He took three weeks to carefully rewrite just the field selection component around a new state management pattern, adding really high quality tests as he went.

He then spent two weeks pair programming with one engineer after another to share the new approach -- *and* he wrote a how-to guide on the wiki on React component architecture and testing.

The team has now built two new components in the new style, and not only have the PM's not complained once about testing, they've actually said that iterating on the UI feels "snappier". We believe that is in large part because the team has been able to more quickly try out changes to the front-end, thanks to the combo of the better state architecture and having a much better safety net. Jeremiah is happy to spend time with any teams that want to try out this new pattern.

*** Story Technique Notes

 - Each of the first four sentences steadily deepens the problem:

   /engineers who were learning React *and* how to write unit tests.../

   /tests randomly fail a lot and *also* have to be rewritten.../

   /The PM's started to get really frustrated.../

   /our PM, Amber, suggested we should maybe just stop testing altogether/

 - Jeremiah's deep dive is posted as a series of "meaningful struggles"

   Within a few setnences, he, tries, fails, learns and then gradually wins.

 - Several moments are brought to life

   /*One day in planning*, Amber asked.../

   /Jeremiah *realized* the underlying problem.../

   /He *spent two weeks* pair programming.../

   /The *PM's said* that iterating on the new UI felt 'snappier'.../

 - The final paragraph shows a "better world"

   In particular, note how the offer for Jeremiah to train other teams is a potential a win for the whole engineering team.

*** The Value Being Illustrated

Many engineers think of the value of tests (if they think of value at all), as "preventing bugs".

I don't believe that's correct.

The economic value of good tests is *not* primarily to prevent bugs but rather to enable *velocity*,

Although a missed bug is an acute and prominent cost to the business, there is *far* more economic damage caused by invisible slowdowns because no one knows how to safely change a system, or every change creates a cascade of unplanned, reactive work.

Good tests enable the team to quickly experiment and learn, while receiving constant feedback from the tests. That pattern of work allows them to rapidly hone in on valuable solutions.

Of course, a team only gets that value...

*...if their tests actually allow them to move faster.*

Having a set of tests which need to be rewritten on every code change is, in many ways, worse than having no tests at all.

So the economic value to improving tests here is:

 a) Immediately speeding the team up, because writing tests the first time is faster.

and

 b) Speeding the team up in the long term, because the tests will provide valuable feedback, without having to be rewritten nearly as often.

** The Death of CalcNextNode

# Steal ideas from Anand retiring ShippingCosts.php or whatever it was

*** The Dry Fact
"We finally replaced CalcNextNode.aspx with a python service."

*** A Three Beat Story
Deep in the mists of time, someone asked an engineer to write some code to select which of our two warehouses was cheaper to ship an item from. At the time, we only had only two warehouses! We only sold 100 different items! So the engineer threw together a quick ASP script in an afternoon. This was a perfectly valid choice! But now... we have 27 warehouses. We ship tens of thousands of different items every day. And yet. As of a few months ago, we still had that one poor ASP script figuring out what to ship from where. That ASP script had gotten so encrusted with crazy shipping logic that the engineers were all terrified to touch it. But then, in February, the Ops Product team announced to all of Supply Chain that our big initiative for the year is... just-in-time ship cost optimization. Which runs straight through our old friend, CalcNextNode.aspx.

So the Inventory Eng Team dug in. First, we spent nearly a full month instrumenting the existing code and wrapping it in every kind of monitoring and logging available. We broke a few things (apologies for the Sev 1's!), but we were finally able to see what it was actually *doing*. We then set up a dual path -- every request to CalcNextNode *also* triggered a request to a new, Python service, and we then logged both responses.

Over time, this let them gradually wear down the logic that was in CalcNextNode.aspx and move more and more of it into a service that we could fully understand, change and scale up as needed.

As of last week, we pushed the button to make the last client just point directly to that new service. We're planning on having a ritual decommissioning of CalcNextNode.aspx next week, you're all invited.

*** Story Technique Notes

*** The Value Being Illustrated
